(deftype URI  [
  scheme (Maybe String)
  host (Maybe String)
  port (Maybe Int)
  path (Maybe String)
  query (Maybe String)
  user (Maybe String)
  password (Maybe String)
  fragment (Maybe String)
  opaque (Maybe String)
])

(defmodule URI
  (doc zero "Creates an empty URI, i.e. one that has only `Nothing` in it.")
  (defn zero []
    (URI.init
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
    ))

  (doc default-ports "is a map of all the services that have default ports—that
we know of—and their port values.")
  (def default-ports {
    @"acap" 674,
    @"afp" 548,
    @"dict" 2628,
    @"dns" 53,
    @"ftp" 21,
    @"ftps" 990,
    @"git" 9418,
    @"gopher" 70,
    @"http" 80,
    @"https" 443,
    @"imap" 143,
    @"ipp" 631,
    @"ipps" 631,
    @"irc" 194,
    @"ircs" 6697,
    @"ldap" 389,
    @"ldaps" 636,
    @"mms" 1755,
    @"msrp" 2855,
    @"mtqp" 1038,
    @"nfs" 111,
    @"nntp" 119,
    @"nntps" 563,
    @"pop" 110,
    @"prospero" 1525,
    @"redis" 6379,
    @"rsync" 873,
    @"rtsp" 554,
    @"rtsps" 322,
    @"rtspu" 5005,
    @"scp" 22,
    @"sftp" 22,
    @"smb" 445,
    @"snmp" 161,
    @"ssh" 22,
    @"svn" 3690,
    @"telnet" 23,
    @"ventrilo" 3784,
    @"vnc" 5900,
    @"wais" 210,
    @"ws" 80,
    @"wss" 443,
  })

  (doc default-port "gets the default `port` for the `scheme` of the URI `u`.
Returns 0 if it’s unknown.")
  (defn default-port [s]
    (Maybe.from (Maybe.apply s &(fn [s] (Map.get &default-ports &s))) 0))

  (doc default-port? "checks whether the `port` of the URI `u` is the default
port for its `scheme`.")
  (defn default-port? [u]
    (Maybe.from (Maybe.apply @(port u) &(fn [p] (= p (default-port @(scheme u)))))
                false))

  (doc hostname "returns the host part of a URI `u`, unwrapping brackets for
IPv6 addresses.

```
(URI.hostname &(URI.parse \"http://[::1]/bar\")) ; => ::1
(URI.hostname &(URI.parse \"http://[::1]/bar\")) ; => [::1]
```
")
  (defn hostname [u]
    (Maybe.apply @(host u)
      &(fn [h]
        (if (and (String.starts-with? &h "[") (String.ends-with? &h "]"))
          (String.substring &h 1 (Int.dec (length &h)))
          h))))

  (doc full-path "returns the full path of a URI `u`.

```
(def uri (URI.parse \"http://foo.com/posts?id=30&limit=5#time=1305298413\"))
(URI.full-path &uri) ; => /posts?id=30&limit=5
```
")
  (defn full-path [u]
    (let [q (Maybe.from @(query u) @"")]
      (String.concat &[(Maybe.from @(path u) @"/")
                       (if (String.empty? &q) @"" @"?")
                       q])))

  (doc absolute? "checks whether a URI `u` is absolute.")
  (defn absolute? [u] (Maybe.just? (scheme u)))
  (doc relative? "checks whether a URI `u` is relative.")
  (defn relative? [u] (Maybe.nothing? (scheme u)))

  (doc userinfo "returns the user-information component for a URI `u`, which
contains the provided username and password.

```
(def uri (URI.parse \"http://admin:password@foo.com\"))
(URI.userinfo &uri) ; => admin:password
```
")
  (defn userinfo [u]
    (String.concat &[
      (Maybe.from @(user u) @"")
      @(if (Maybe.just? (password u)) ":" "")
      (Maybe.from @(password u) @"")
    ]))

  (doc str "prints the URL `u` as idempotently as possible, i.e. as the parsed
string.

```
(def uri (URI.parse \"http://admin:password@foo.com\"))
(URI.str &uri) ; => \"http://admin:password@foo.com\"
```
")
  (defn str [u]
    (let [s @(scheme u)
          o @(opaque u)
          usr @(user u)
          q @(query u)
          h @(host u)
          p @(port u)
          pth @(path u)
          f @(fragment u)
         ]
      (String.concat &[
        (Maybe.from (Maybe.apply s
                        &(fn [s] (String.concat &[
                                    s
                                    @":"
                                    @(if (Maybe.just? &o) "" "//")
                                ])))
                    @""
        )
        (Maybe.from o @"")
        (Maybe.from (Maybe.apply usr
                                 &(fn [usr] (String.concat &[(userinfo u) @"@"])))
                    @""
        )
        (Maybe.from h @"")
        (Maybe.from (Maybe.apply p
                                 &(fn [p] (if (default-port? u)
                                           @""
                                           (String.concat &[@":" (str p)]))))
                    @""
        )
        @"/"
        (Maybe.from pth @"")
        (Maybe.from (Maybe.apply q &(fn [q] (String.concat &[@"?" q]))) @"")
        (Maybe.from (Maybe.apply f &(fn [f] (String.concat &[@"#" f]))) @"")
      ])
    )
  )

  (doc = "is defined as the equality of all members of URIs `u1` and `u2`.

N.B.: We’re being cute by using string equality (which gets rid of differences
between explicit/implicit port assignments). That might not always be desirable!")
  (sig = (Fn [(Ref URI) (Ref URI)] Bool))
  (defn = [u1 u2] (= (str (the (Ref URI) u1)) (str u2)))
)

(deftype URIParser [
  source String
  offset Int
])

(defmodule URIParser
  (defn from-string [s] (init @s 0))

  (defn c [p] (String.char-at (source p) @(offset p)))
  (defn nxt [p] (String.char-at (source p) (Int.inc @(offset p))))
  (defn alpha? [p] (Char.alpha? (c p)))
  (defn num? [p] (Char.num? (c p)))
  (defn end? [p] (= (length (source p)) @(offset p)))
  (defn end-of-host? [p] (or* (= (c p) \/) (= (c p) \?) (= (c p) \#)))
  (defn adv [p] (update-offset @p &Int.inc))
  (defn bck [p] (update-offset @p &Int.dec))
  (defn from [p frm] (String.substring (source p) frm @(offset p)))
  (defn to [p t] (String.substring (source p) @(offset p) t))

  ; core?
  (defn int-from-str [s]
    (Array.reduce &(fn [acc n] (+ (* acc 10) (Char.meaning n)))
                  0
                  &(String.chars s)))

  (defn parse-authority [p res] res)
  (defn parse-path [p res] res)

  (defn parse-fragment [po res]
    (let-do [p (adv &po)
             pref &p
             st @(offset &p)]
      (while true
        (cond
          (end? &p)
            (do
              (set! res (Result.map res &(fn [res]
                (URI.set-fragment res (Maybe.Just (from pref st))))))
              (break))
          (set! p (adv &p))))
      res))

  (defn parse-query [po res]
    (let-do [p (adv &po)
             pref &p
             st @(offset &p)]
      (while true
        (cond
          (end? &p)
            (do
              (set! res (Result.map res &(fn [res]
                (URI.set-query res (Maybe.Just (from pref st))))))
              (break))
          (= (c &p) \#)
              (do
                (set! res (parse-fragment @pref
                  (Result.map res &(fn [res] (URI.set-query res (Maybe.Just (from pref st)))))))
                (break))
          (set! p (adv &p))))
      res))

  (defn parse-path [p res]
    (let-do [st @(offset &p)
             pref &p]
      (while true
        (if (end? &p)
          (do
            (set! res (Result.map res &(fn [res] (URI.set-path res (Maybe.Just (from pref st))))))
            (break))
          (case (c &p)
            \?
              (do
                (set! res (parse-query @&p
                  (Result.map res &(fn [res] (URI.set-path res (Maybe.Just (from pref st)))))))
                (break))
            \#
              (do
                (set! res (parse-fragment @&p
                  (Result.map res &(fn [res] (URI.set-path res (Maybe.Just (from pref st)))))))
                (break))
            (set! p (adv &p)))))
      res))

  (defn parse-relative-slash [p res]
    (if (end? &p)
      res
      (if (= (nxt &p) \/)
        (parse-authority (adv &p) res)
        (parse-path (adv &p) res))))

  (defn parse-relative [p res]
    (if (end? &p)
      res
      (case (c &p)
        \/ (parse-relative-slash p res)
        \? (parse-query p res)
        \# (parse-fragment p res)
        (parse-path p res))))

  (defn parse-port [p res]
    (let-do [st @(offset &p)
             pref &p]
      (while true
        (cond
          (num? &p)
            (set! p (adv &p))
          (end-of-host? &p)
            (do
              (set! res (parse-path (adv &p)
                (Result.map res &(fn [res] (URI.set-port res (Maybe.Just
                              (int-from-str &(from pref st))))))))
              (break))
          (do
            (set! res (Result.Error
              (fmt "Invalid URI: bad port at character %d" @(offset &p))))
            (break))))
      res))

  (defn parse-host [p res]
    (if (= (c &p) \/)
      (parse-path p res)
      (let-do [bracket-flag false
               st @(offset &p)
               pref &p]
        (while true
          (cond
            (and (= (c &p) \:) (not bracket-flag))
              (do
                (set! res (parse-port (adv &p)
                  (Result.map res &(fn [res] (URI.set-host res (Maybe.Just (from pref st)))))))
                (break))
            (end-of-host? &p)
              (do
                (set! res (parse-path (adv &p)
                  (Result.map res &(fn [res] (URI.set-host res (Maybe.Just (from pref st)))))))
                (break))
            (do
              (when (= (c &p) \[) (set! bracket-flag true))
              (when (= (c &p) \]) (set! bracket-flag false))
              (set! p (adv &p)))))
        res)))

  (defn parse-userinfo [p res]
    (let-do [pw-flag false
             st @(offset &p)
             pref &p]
      (while true
        (cond
          (= (c &p) \@)
            (do
              (set! res (parse-host (adv &p)
                (Result.map res &(fn [res]
                  (if pw-flag
                    (URI.set-password res (Maybe.Just (from pref st)))
                    (URI.set-user res (Maybe.Just (from pref st))))))))
              (break))
          (= (c &p) \:)
            (do
              (set! res (Result.map res &(fn [res] (URI.set-user res (Maybe.Just (from pref st))))))
              (set! pw-flag true)
              (set! p (adv &p))
              (set! st @(offset &p)))
          (set! p (adv &p))))
      res))

  (defn parse-authority [po res]
    (let-do [p (adv &po)
             st @(offset &p)]
      (while true
        (cond
          (= (c &p) \@)
            (do
              (set! res (parse-userinfo (set-offset @&p st) res))
              (break))
          (end-of-host? &p)
            (do
              (set! res (parse-host (set-offset @&p st) res))
              (break))
          (set! p (adv &p))))
      res))

  (defn parse-path-or-authority [p res]
    (if (= (c &p) \/)
      (parse-authority p res)
      (parse-path (bck &p) res)))

  (defn parse-no-scheme [p res]
    (if (= (c &p) \#)
      (parse-fragment p res)
      (parse-relative p res)))

  (defn parse-scheme [p res]
    (let-do [st @(offset &p)
             pref &p]
      (while true
        (cond
          (or* (alpha? &p) (num? &p) (= (c &p) \-) (= (c &p) \.) (= (c &p) \+))
            (set! p (adv &p))
          (= (c &p) \:)
            (do
              (set! res (Result.map res &(fn [res] (URI.set-scheme res (Maybe.Just (from pref st))))))
              (if (= (nxt &p) \/)
                (do
                  (set! res
                        (parse-path-or-authority
                          (update-offset @&p &(fn [x] (+ x 2))) res))
                  (break))
                (do
                  (set! res (Result.map res &(fn [res] (URI.set-opaque res
                      (Maybe.Just (from pref (Int.dec (length (source pref)))))))))
                  (break))))
          (do
            (set! res (parse-no-scheme (set-offset @&p 0) res))
            (break))))
      res))

  (defn parse [p]
    (let [res (Result.Success (URI.zero))]
      (if (alpha? &p)
        (parse-scheme p res)
        (parse-no-scheme p res))))
)

(defmodule URI
  (doc parse "Parses a URI from a string `s`.")
  (defn parse [s]
    (URIParser.parse (URIParser.from-string s)))
)

(defmodule URICopy
  (defn = [u1 u2]
    (URI.= &u1 &u2))
)
