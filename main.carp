(deftype URI  [
  scheme (Maybe String)
  host (Maybe String)
  port (Maybe Int)
  path (Maybe String)
  query (Maybe String)
  user (Maybe String)
  password (Maybe String)
  fragment (Maybe String)
  opaque (Maybe String)
])

(defmodule URI
  (defn empty []
    (URI.init
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
      (Maybe.Nothing)
    ))

  (def default-ports {
    @"acap" 674,
    @"afp" 548,
    @"dict" 2628,
    @"dns" 53,
    @"ftp" 21,
    @"ftps" 990,
    @"git" 9418,
    @"gopher" 70,
    @"http" 80,
    @"https" 443,
    @"imap" 143,
    @"ipp" 631,
    @"ipps" 631,
    @"irc" 194,
    @"ircs" 6697,
    @"ldap" 389,
    @"ldaps" 636,
    @"mms" 1755,
    @"msrp" 2855,
    @"mtqp" 1038,
    @"nfs" 111,
    @"nntp" 119,
    @"nntps" 563,
    @"pop" 110,
    @"prospero" 1525,
    @"redis" 6379,
    @"rsync" 873,
    @"rtsp" 554,
    @"rtsps" 322,
    @"rtspu" 5005,
    @"scp" 22,
    @"sftp" 22,
    @"smb" 445,
    @"snmp" 161,
    @"ssh" 22,
    @"svn" 3690,
    @"telnet" 23,
    @"ventrilo" 3784,
    @"vnc" 5900,
    @"wais" 210,
    @"ws" 80,
    @"wss" 443,
  })

  (defn default-port [s]
    (Maybe.from (Maybe.apply s (fn [s] (Map.get &default-ports &s))) 0))

  (defn default-port? [u]
    (Maybe.from (Maybe.apply @(port u) (fn [p] (= p (default-port @(scheme u)))))
                false))

  (defn hostname [u]
    (Maybe.apply @(host u)
      (fn [h]
        (if (and (String.starts-with? &h "[") (String.ends-with? &h "]"))
          (String.substring &h 1 (Int.dec (length &h)))
          h))))

  (defn full-path [u]
    (let [q (Maybe.from @(query u) @"")]
      (String.concat &[(Maybe.from @(path u) @"/")
                       (if (String.empty? &q) @"" @"?")
                       q])))

  (defn absolute? [u] (Maybe.just? (scheme u)))
  (defn relative? [u] (Maybe.nothing? (scheme u)))

  (defn userinfo [u]
    (String.concat &[
      (Maybe.from @(user u) @"")
      @(if (Maybe.just? (password u)) ":" "")
      (Maybe.from @(password u) @"")
    ]))

  (defn str [u]
    (let [s @(scheme u)
          o @(opaque u)
          usr @(user u)
          q @(query u)
          h @(host u)
          p @(port u)
          pth @(path u)
          f @(fragment u)
         ]
      (String.concat &[
        (Maybe.from (Maybe.apply s
                        (fn [s] (String.concat &[
                                    s
                                    @":"
                                    @(if (Maybe.just? &o) "" "//")
                                ])))
                    @""
        )
        (Maybe.from o @"")
        (Maybe.from (Maybe.apply usr
                                 (fn [usr] (String.concat &[(userinfo u) @"@"])))
                    @""
        )
        (Maybe.from h @"")
        (Maybe.from (Maybe.apply p (fn [p] (if (default-port? u) @"" (str p))))
                    @""
        )
        (Maybe.from pth @"")
        (Maybe.from (Maybe.apply q (fn [q] (String.concat &[@"?" q]))) @"")
        (Maybe.from (Maybe.apply f (fn [f] (String.concat &[@"#" f]))) @"")
      ])
    )
  )

  (defn normalize [u]
    (assert (= "" "TODO")))
)

(deftype URIParser [
  source String
  offset Int
])

(defmodule URIParser
  (defn from-string [s] (init @s 0))

  (defn c [p] (String.char-at (source p) @(offset p)))
  (defn nxt [p] (String.char-at (source p) (Int.inc @(offset p))))
  (defn alpha? [p] (Char.alpha? (c p)))
  (defn num? [p] (Char.num? (c p)))
  (defn end? [p] (= (Int.dec (length (source p))) @(offset p)))
  (defn end-of-host? [p] (or* (= (c p) \/) (= (c p) \?) (= (c p) \#)))
  (defn adv [p] (update-offset @p &Int.inc))
  (defn bck [p] (update-offset @p &Int.dec))
  (defn from [p frm] (String.substring (source p) frm @(offset p)))
  (defn to [p t] (String.substring (source p) @(offset p) t))

  (defn parse-path [p res] res)
  (defn parse-fragment [p res] res)
  (defn parse-relative [p res] res)
  (defn parse-host [p res] res)

  (defn parse-userinfo [p res]
    (let-do [pw-flag false
             st @(offset &p)]
      (while true
        (cond
          (= (c &p) \@)
            (do
              (set! res (parse-host (adv &p)
                          (if pw-flag
                            (URI.set-password @&res (Maybe.Just (from &p st)))
                            (URI.set-user @&res (Maybe.Just (from &p st))))))
              (break))
          (= (c &p) \:)
            (do
              (set! res (URI.set-user @&res (Maybe.Just (from &p st))))
              (set! pw-flag true)
              (set! p (adv &p))
              (set! st @(offset &p)))
          (set! p (adv &p))))
      res))

  (defn parse-authority [po res]
    (let-do [p (adv &po)
             st @(offset &p)]
      (while true
        (cond
          (= (c &p) \@)
            (do
              (set! res (parse-userinfo (set-offset @&p st) res))
              (break))
          (end-of-host? &p)
            (do
              (set! res (parse-host (set-offset @&p st) res))
              (break))
          (set! p (adv &p))))
      res))

  (defn parse-path-or-authority [p res]
    (if (= (c &p) \/)
      (parse-authority p res)
      (parse-path (bck &p) res)))

  (defn parse-no-scheme [p res]
    (if (= (c &p) \#)
      (parse-fragment p res)
      (parse-relative (bck &p) res)))

  (defn parse-scheme [p res]
    (let-do [st @(offset &p)]
      (while true
        (cond
          (or* (alpha? &p) (num? &p) (= (c &p) \-) (= (c &p) \.) (= (c &p) \+))
            (set! p (adv &p))
          (= (c &p) \:)
            (do
              (set! res (URI.set-scheme res (Maybe.Just (from &p st))))
              (if (= (nxt &p) \/)
                (do
                  (set! res
                        (parse-path-or-authority
                          (update-offset @&p &(fn [x] (+ x 2))) res))
                  (break))
                (do
      (set! res (URI.set-opaque res
                                (Maybe.Just (from &p (Int.dec (length (source &p)))))))
                  (break))))
          (do
            (set! res (parse-no-scheme (set-offset @&p 0) res))
            (break))))
      res))

  (defn parse [p]
    (let [res (URI.empty)]
      (if (alpha? &p)
        (parse-scheme p res)
        (parse-no-scheme p res))))
)

(defmodule URI
  (defn parse [s]
    (URIParser.parse (URIParser.from-string s)))
)
